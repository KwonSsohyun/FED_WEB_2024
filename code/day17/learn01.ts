// ▶ 리액트 훅(React Hooks)
/*
    단순히 정보를 관리하는 것을 넘어서서 정보의 변경을 감지한다거나
    정보의 변경을 늦추거나 같이 특수한 경우가 있기 때문
    특별하게 정보를 관리해야하는 경우가 생긴다.
    그래서 나온것들이 특수한 관리를 위한 Hook들



    ▶ useEffect
       → 무언가가 반영되는 것을 감지하는 훅

         특정정보가 다른 정보에 종속되어서 해당 정보가 변경되면 같이 변경되어야 하는 경우
         혹은 변경되면 제거되거나 추가되야 하는 경우
         함께 변화하는걸 일반적으로 작성하면 동시에 changer함수를 호출하는 방법밖에 없다.
         그리고 이러한 방법은 변화하는 수단이 많을수록 귀찮아진다.

         ⇒ useEffect 훅
            특정 값의 변경을 감지해서 호출되는 함수
            A가 바뀌면 B가 바뀌어야한다.
            그렇다면 A를 감시해서 A의 변화가 감지되면 B를 바꾼다면?


         ⇒ useEffect(함수, [감지목록]);
            감지목록에 적힌 변수의 값이 변화한다면 함수가 실행되는 구조

            특정값의 변화를 감지해서 다음 값의 변화를 만들 때 유용한 훅


         ⇒ useEffect 2가지 특이점
            ● 맨처음 한번은 무조건 그냥 실행
              그렇다면 [] 빈 배열을 감지목록으로 넣는다면?
              그러면 한 번만 실행하는 함수를 만들 수 있다.

              이걸 왜 쓰느냐?
              리액트에서는 fetch등의 외부 데이터를 가져와서 이용하는 경우가 많다.
              그때 단순히 가져오는 것은 렌더링이 안된다.
              렌더링을 위해서는 Hook으로 값을 변화시켜야한다.

              이때 fetch가 값을 변화시켜서 렌더링이 다시되면 fetch도 다시 동작
              fetch등과 같이 지연된 동작에 의해 렌더링을 강제로 다시해야하는 함수가 있을때
              한 번만 동작할 수 있도록 할때 위 방법을 이용
            
            ● 만약에 내가 감지목록에 의해서 정보를 과다하게 추가하는 경우가 있다면?
              최종적으로 해당 리액트 컴포넌트가 사라질때 실행하는 함수가 필요한 경우
              useEffect는 반환값으로 함수를 받는다.

              리액트 태그가 다시 그려지는 원리 → 삭제 후 덮어쓰기
              여러가지 태그의 변화를 편리하게 이어지도록 하는 훅


                useEffect(()=>{
                    if(number == 0) statechanger('zero');
                    else if(number < 0) statechanger('minus');
                    else statechanger('plue');

                    return ()=>{
                        console.log('최종적으로 컴포넌트가 삭제될때만 불리는 함수');
                    }

                },[number]);





    ▶ useMemo
       → 메모제이션 훅
         리액트 컴포넌트를 만들다보면 렌더링이 될 때마다 
         새로 만들어지는 변수나 함수가 매우 많다.

         변수를 만들고 이용하는 과정
         [--변수 생성--][--변수 이용--][--변수 삭제--]

         ⇒ [--변수 이용--]
            변수를 생성하고 삭제하는걸 없앨 수 있다면?
            성능 좋은 컴포넌트를 만들 수 있겠다.

         ⇒ 메모제이션
            이전에 만들어둔 값을 없애지않고 계속 이용해서 메모리와 속도를 향상시키는 기법
            일반 값과 함수를 메모제이션하는 훅

         ⇒ const value = useMemo(()=>{ return value; }, [value]);
            [] 의존성 목록에 적힌 값이 변화하면 그때 함수를 호출한다.
            리턴값이 함수가 아닌 변수값으로 useMemo의 결과값이 된다.
            [value]에 적힌 값이 바뀌는 경우에 메모제이션된 값을 바꾸는 훅

            리턴값 정보가 계속 유지되다가 의존성 목록 변화가 감지되면
            리턴값을 바꾸는 것



    ▶ useCallback
       → 함수를 메모제이션 한다.
         
         ⇒ useCallback(함수, [의존성 목록])
            리턴값을 넣은 함수가 나온다.
            해당 함수는 다시 렌더링이 되어도 계속 유지가 되어 다시 바꿀 필요없는 함수를 메모제이션

            <div onClick={(e)=>{e.target}}></div>
            이런것들은 (e)=>{e.target}보통 이런게 반복적이니까.





    ▶ useRef
       → 렌더링이 없는 변화를 이용하는 훅
         useState랑 크게 다를바 없다.
         한개의 정보를 관리하는 훅

         ⇒ 값이 변화해도 렌더링이 안된다.
            const value = useRef(null);
            → 값을 {current: null} 이렇게 받아오기 때문


         ⇒ HTMLElement를 직접 제어할 때 이용
            렌더링 없이 태그의 변화를 일으키고 싶을 때

            리액트의 모든 태그는 ref라는 속성이 있다.
            reference라는 값이어서 해당 태그의 this를 매개변수로 넣는 이벤트 함수

         ⇒ ref={ref}
            ref.current 로 접근해서 사용한다.

         ⇒ (this, ref) => ref.current = this; 동작원리
            useRef로 받아온 정보의 current변수에 해당 태그를 넣는다.
            단, 렌더링 없이

            useRef로 받아온 태그가 current에 들어있기 때문에
            onChange같이 특정 이벤트 함수가 불릴 때
            렌더링 없이 직접적으로 태그를 변경할 수가 있다.
            DOM 구조에 연결된다.




    ▶ useDeferredValue, useTransition
       → 지연 훅
         값이 변화해야할 때 우선순위를 나중으로 늦춘다.
         
         정보를 관리하다보면 정보의 변환 순서가 중요한 경우가 있다.
         그렇다고 내가 직접 순서를 지정해서 작성하는건 번거롭고
         자동으로 순서가 바뀐다면 좋겠다.

         여러개의 값 변화를 작성할 때 
         밑에다가 적은 것처럼 동작되고 싶다.

         훅으로 변화를 늦추는게 지연 훅

         ⇒ 값 변경 지연 훅, 함수 지연 훅

           ● useDeferredValue   : 값 변경 지연 훅
             const value = useDeferredValue(useStateValue);
             → useStateValue를 받아와서 그걸 value로 뽑아서 쓰는 훅
               useStateValue가 바뀐다면? 바로 바뀌지 않는다.

               인간이 느끼는 가장 짧은 반응속도 → 0.01초
               체감은 못하지만 우선순위를 늦춰서 나중에 바뀌긴 한다.

               값변경은 지금 하지만 적용이 나중에 되게 하는거에 가깝다.


           ● useTransition   : 함수 호출 지연 훅
             함수 실행 자체를 나중에 실행되도록 지연
             특정 함수의 실행을 나중에 실행되도록 지연시켜서 변화를 늦추는 훅

             const [isPendding, startWith] = useTransition();
             → isPendding   : 변화 전,후 표시 (true, false)
             → startWith(()=>{ change(); })
               함수에 의해 나중에 호출되어서 지연되어 변화를 일으킨다.




    여기까지가 React의 일반적인 훅들
    이제 일반적인 훅들을 이용해서 사용자만의 커스터마이징 훅들을 만들고 이용해야한다.


*/