// ▶ MobX 상태 관리 라이브러리
/*

   ⇒ MobX Inject 기능이 렌더를 구분하기 위해 사용된다.
      Inject 없이도 Observable한 값을 변경한다면 해당 값을 참조하는 모든 컴포넌트만 렌더링되게 업데이트

      Inject를 사용했던 이유 → 값을 추적하는 성능이 조금 떨어졌다.
      값을 추적하는 성능 알고리즘을 따로 제작 
      → Inject 없이도 동일한 효과


   ⇒ 리액트에서 값이 변경되는 경우에 렌더링이 호출
      값이 변경이 한번에 여러번된다면?
      → 렌더링이 여러번 호출

      MobX에서 Observable한 값을 변경할 때도 
      동일하게 여러개의 값을 한번에 변경하면 각각의 값별로 한 번씩 렌더링

      여러개의 값을 변경하고 여러번 변경해도 
      최종적으로 변경한 한번만 일괄적으로 변경하도록 자동 처리

      MobX에서는 값이 변경될 때 그걸 바로 적용시키지 않고 나중에 한번에 적용시키기 위한 데코레이터




   ▶ @action 데코레이터
      일괄 데코레이터
      따로따로 처리해서 성능을 잡아먹던 렌더링을 최종적으로 한번만 호출하게 변경

      makeAutoObservable 함수가 @action을 메서드 함수에 자동 추가




   ▶ computed
      → "계산된 값" 기능 사용하고 싶어졌다.(값 캐싱)
         내가 감시 중인 어떤 값이 변경이 안되었을 때는 
         특정 함수의 결과값을 다시 계산하고 싶지 않은 경우

         감시 중인 값이 변경이 안되면 함수의 결과값을 다시 계산하지 않고
         이전에 계산한 값을 그대로 이용하도록

         이것도 데코레이터? ❌
         
         ⇒ get 함수 사용 ⭕
            property로 우리가 어떤 함수를 변수처럼 이용할 수 있게 만드는 키워드
            get 방식을 붙히고 싶다면, 매개변수 0개여야 한다.

            set 함수 → 매개변수 1개

            get property를 함수에 붙히면 computed value가 된다.
            값이 캐싱되어서 값 변경되지 않으면 함수를 다시 부르지 않게 된다.

            계산된 값이 변경될 여지가 없다면
            함수를 다시 호출하지 않도록 만들 수 있다.




   ▶ runInAction 함수
      → Action이 함수 동작 안에 포함되어있다.
        MobX는 기본적으로 React스럽게 사용하기 위해서 
        동기적인 구조를 가지고 있다.

        계획대로만 사는건 어렵다.

        어쩔 수 없이 "비동기적인 동작" 을 
        MobX에 포함시켜야 하는 경우 생긴다.

        MobX는 비동기에 친화적이지 않아서 오류를 내거나 실행이 안되는 경우가 빈번

        비동기적인 행동의 결과를 
        나중에 파이프라인에 추가하기위한 함수!


      → runInAction(()=>{});
        그러면 넣은 함수가 @action 데코레이터의 동작을 지원받아서 파이프라인에 등록
        @action이 아닌 함수를 @action으로 변경하는 기능         

        비동기로 인해서 꼬일 수 있는 데이터 변경이 파이프라인에 직접 삽입하여 꼬이지 않도록
        비동기를 동기화 하는 기능

        비동기를 동기화 하는 기능
        비동기를 동기화 하는 방법을 알게 되었다.




   ▶ autorun, reaction, when 이벤트
      → 3개 전부 아무데서나 작성 가능

      → 단지 "한 번만" 불려야한다. 
        그래서 일반적으로 "생성자" 작성한다.

        MobX 동기화 시스템
        A → B → C → ... → Z
        비동기로 이벤트 같은걸 만들고 싶을 수 있다.

        특정 상황을 트리거로 이벤트를 만들고 싶다.

        동기화 시스템 MobX에서 
        비동기 시스템 이벤트를 만들기 위한 기능 추가!



   ▶ autorun()
      observable 값이 변경되려고 하면 자동으로 실행된다.
      @action 함수가 호출될 때
      아무때나 호출된다.

      autorun(()=>{}) 방식으로 등록
      console.log(123);          한번만 실행
      console.log(this.number);  여러번 실행

      그 이유는 @observable한 맴버 변수가 함수에 들어있느냐 아니냐의 차이

      값을 추적하는 원리 때문
      prototype.bind - 연결하다, 묶다, 엮다.

      객체에 추가적인 정보를 더하는 기능
      어딘가에 등록된(bind)된 변수의 값이 변화하는걸 감지

      observable한 변수가 누가 사용되는지를 미리 알 수 있다.

      bind된 값으로 누구를 이용하는지를 안다면 해당하는 변수를 이용했을때만 호출되게 만들 수 있다.

      autorun의 동작은 안에 들어있는 함수에서 
      사용하는 observable 값이 변경될때만 실행된다.




   ▶ reaction()
      autorun은 단순하게 값이 변경되려고 '하면' 불린다.
      observable 값이 변경되면 자동으로 실행된다.

      변경되려고 하면이 아닌 실제 값이 변경되면 불리고 싶다.
      값이 변경을 감지하기위한 함수 + 해당값을 매개변수로 받아와서 이용하는 콜백함수

      reaction(()=>this.number, (value:number, prev:number)=>{});
      
      순서 정해져 있음
      value:number 현재값, prev:number 이전값

      첫 번째 값에 
      ● ()=>this.number 하면 해당 값이 변경되는걸 감지하는 이벤트가 되지만,
      ● ()=>this.number % 2 == 0 값이 연산값을 리턴하면 연산된 값이 변경되는걸 감지하는 이벤트가 된다.

      reaction 이벤트는 한 가지의 용도가 아닌 
      두 개의 용도로 사용할 수가 있다.




   ▶ when()
      reaction 처럼 함수 2개를 등록

      첫 번째 함수의 결과값이 true일때만 
      두 번째 함수를 콜백 호출하는 기능

      when(()=>1==2, ()=>{});
      특정 상황에서만 함수가 호출 되도록하는 특수 이벤트

      조건이 만족하면 1회만 동작됨 
      조건을 만족하면 실행 후 삭제되도록 변경됨

      ● 조건을 만족하면 특정 함수를 한번 실행하도록 when 기능
      
      ● 혹은 when(()=>1==2) 라고 compare함수만 등록해서 조건을 만족하면 
        Promise 비동기 동작이 이루어지게 비동기 함수로써 기능


*/